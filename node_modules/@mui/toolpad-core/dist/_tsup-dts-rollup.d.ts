/// <reference types="node" />
/// <reference types="react" />

import type { BoxProps } from '@mui/material';
import type { Branded } from '@mui/toolpad-utils/types';
import { Emitter } from '@mui/toolpad-utils/events';
import type express from 'express';
import { IncomingMessage } from 'node:http';
import type { JSONSchema7 } from 'json-schema';
import { JWT } from '@auth/core/jwt';
import { Maybe } from '@mui/toolpad-utils/types';
import * as React_2 from 'react';
import type { SerializedError } from '@mui/toolpad-utils/errors';
import { ServerResponse } from 'node:http';
import { SxProps } from '@mui/material';
import type { ThemeOptions } from '@mui/material';

export declare function addFragment(dom: AppDom, fragment: AppDom, parentId: NodeId, parentProp: string, parentIndex?: string | undefined): AppDom;

export declare function addNode<Parent extends AppDomNode, Child extends AppDomNode>(dom: AppDom, newNode: Child, parent: Parent, parentProp: ParentPropOf<Child, Parent>, parentIndex?: string): AppDom;

declare type AllowedChildren = {
    app: {
        pages: 'page';
        connections: 'connection';
        themes: 'theme';
    };
    theme: {};
    connection: {};
    page: {
        children: 'element';
        queries: 'query';
        mutations: 'mutation';
    };
    element: {
        [prop: string]: 'element';
    };
    query: {};
    mutation: {};
};

declare type AllowedChildTypesOf<N extends AppDomNode> = AllowedChildTypesOfType<TypeOf<N>>;

declare type AllowedChildTypesOfType<T extends AppDomNodeType> = AllowedChildren[T];

declare interface AnyValueType extends ValueTypeBase {
    type?: undefined;
    default?: any;
}
export { AnyValueType }
export { AnyValueType as AnyValueType_alias_1 }

export declare interface AppDom {
    nodes: AppDomNodes;
    root: NodeId;
    version?: number;
}

export declare type AppDomNode = AppDomNodeOfType<AppDomNodeType>;

export declare interface AppDomNodeBase {
    readonly id: NodeId;
    readonly type: AppDomNodeType;
    readonly name: string;
    readonly parentId: NodeId | null;
    readonly parentProp: string | null;
    readonly parentIndex: string | null;
    readonly attributes: {};
}

declare type AppDomNodeInitOfType<T extends AppDomNodeType> = Omit<AppDomNodeOfType<T>, ReservedNodeProperty | 'name'> & {
    name?: string;
};

declare type AppDomNodeOfType<K extends AppDomNodeType> = {
    app: AppNode;
    connection: ConnectionNode;
    theme: ThemeNode;
    page: PageNode;
    element: ElementNode;
    query: QueryNode;
    mutation: MutationNode;
}[K];

export declare type AppDomNodes = Record<NodeId, AppDomNode>;

declare type AppDomNodeType = 'app' | 'connection' | 'theme' | 'page' | 'element' | 'query' | 'mutation';

declare interface ApplicationVm {
    scopes: {
        [id in string]?: RuntimeScope;
    };
    bindingScopes: {
        [id in string]?: string;
    };
}
export { ApplicationVm }
export { ApplicationVm as ApplicationVm_alias_1 }

/**
 * Apply a diff to a dom and return the new dom.
 */
export declare function applyDiff(dom: AppDom, diff: DomDiff): AppDom;

export declare interface AppNode extends AppDomNodeBase {
    readonly type: 'app';
    readonly parentId: null;
    readonly attributes: {
        readonly plan?: ToolpadPlan;
        readonly authentication?: {
            readonly providers?: AuthProviderConfig[];
            readonly restrictedDomains?: string[];
        };
        readonly authorization?: {
            readonly roles?: {
                readonly name: string;
                readonly description?: string;
            }[];
        };
    };
}

declare interface ArgControlSpec {
    type: 'boolean' | 'number' | 'range' | 'object' | 'radio' | 'buttons' | 'select' | 'string' | 'color' | 'slot' | 'slots' | 'layoutSlot' | 'multiSelect' | 'date' | 'json' | 'markdown' | 'GridColumns' | 'SelectOptions' | 'ChartData' | 'HorizontalAlign' | 'VerticalAlign' | 'event' | 'NumberFormat' | 'ColorScale' | 'ToggleButtons' | 'RowIdFieldSelect' | 'DataProviderSelector';
    bindable?: boolean;
    hideLabel?: boolean;
}
export { ArgControlSpec }
export { ArgControlSpec as ArgControlSpec_alias_1 }

declare type ArgTypeDefinition<P extends object = {}, K extends keyof P = keyof P> = PropValueType & {
    /**
     * To be used instead of the property name for UI purposes in the editor.
     */
    label?: string;
    /**
     * The control to be used to manipulate values for this property from the editor.
     */
    control?: ArgControlSpec;
    /**
     * A description of the property, to be used to supply extra information to the user.
     */
    description?: string;
    /**
     * A default value for the property.
     * @deprecated Use `default` instead.
     */
    defaultValue?: P[K];
    /**
     * The property that will supply the default value.
     */
    defaultValueProp?: keyof P & string;
    /**
     * The property that is used to control this property.
     */
    onChangeProp?: keyof P & string;
    /**
     * Provides a way to manipulate the value from the onChange event before it is assigned to state.
     * @param {...any} params params for the function assigned to [onChangeProp]
     * @returns {any} a value for the controlled prop
     */
    onChangeHandler?: (...params: any[]) => P[K];
    /**
     * For compound components, this property is used to control the visibility of this property based on the selected value of another property.
     * If this property is not defined, the property will be visible at all times.
     * @param {P} props all the prop bindings of the component
     * @returns {boolean} a boolean value indicating whether the property should be visible or not
     */
    visible?: ((props: P) => boolean) | boolean;
    /**
     * Name of category that this property belongs to.
     */
    category?: string;
    tsType?: string;
};
export { ArgTypeDefinition }
export { ArgTypeDefinition as ArgTypeDefinition_alias_1 }

declare type ArgTypeDefinitions<P extends object = {}> = {
    [K in keyof P & string]?: ArgTypeDefinition<P, K>;
};
export { ArgTypeDefinitions }
export { ArgTypeDefinitions as ArgTypeDefinitions_alias_1 }

declare interface ArrayValueType extends ValueTypeBase {
    /**
     * the property is an array.
     */
    type: 'array';
    /**
     * A JSON schema describing the array.
     */
    schema?: JSONSchema7;
    default?: any[];
}
export { ArrayValueType }
export { ArrayValueType as ArrayValueType_alias_1 }

export declare function assertIsApp(node: AppDomNode): asserts node is AppNode;

export declare function assertIsConnection<P>(node: AppDomNode): asserts node is ConnectionNode<P>;

export declare function assertIsElement<P>(node: AppDomNode): asserts node is ElementNode<P>;

export declare function assertIsMutation<P>(node: AppDomNode): asserts node is MutationNode<P>;

export declare function assertIsPage(node: AppDomNode): asserts node is PageNode;

export declare function assertIsQuery<P>(node: AppDomNode): asserts node is QueryNode<P>;

export declare function assertIsTheme(node: AppDomNode): asserts node is ThemeNode;

export declare type AuthProvider = 'github' | 'google' | 'azure-ad' | 'credentials';

export declare interface AuthProviderConfig {
    readonly provider: AuthProvider;
    readonly roles?: {
        source: string[];
        target: string;
    }[];
}

declare type BindableAction = JsExpressionAction | NavigationAction;
export { BindableAction }
export { BindableAction as BindableAction_alias_1 }

declare type BindableAttrEntries = [string, BindableAttrValue<any>][];
export { BindableAttrEntries }
export { BindableAttrEntries as BindableAttrEntries_alias_1 }

declare type BindableAttrValue<V> = V | SecretAttrValue<V> | JsExpressionAttrValue | EnvAttrValue | BindableAction;
export { BindableAttrValue }
export { BindableAttrValue as BindableAttrValue_alias_1 }

declare type BindableAttrValues<P = Record<string, unknown>> = {
    readonly [K in keyof P]?: BindableAttrValue<P[K]>;
};
export { BindableAttrValues }
export { BindableAttrValues as BindableAttrValues_alias_1 }

export declare type BindableProps<T> = {
    [K in keyof T]: T[K] extends BindableAttrValue<any> ? K : never;
}[keyof T & string];

/**
 * Represents the actual state of an evaluated binding.
 */
declare type BindingEvaluationResult<T = unknown> = {
    /**
     * The actual value.
     */
    value?: T;
    /**
     * The evaluation of the value resulted in error.
     */
    error?: Error;
    /**
     * The parts that this value depends on are still loading.
     */
    loading?: boolean;
};
export { BindingEvaluationResult }
export { BindingEvaluationResult as BindingEvaluationResult_alias_1 }

declare interface BooleanValueType extends ValueTypeBase {
    /**
     * the property is a boolean.
     */
    type: 'boolean';
    default?: boolean;
}
export { BooleanValueType }
export { BooleanValueType as BooleanValueType_alias_1 }

export declare const CanvasEventsContext: React_2.Context<Emitter<RuntimeEvents> | null>;

export declare type ChildNodesOf<N extends AppDomNode> = {
    [K in keyof AllowedChildTypesOf<N>]: AllowedChildTypesOf<N>[K] extends AppDomNodeType ? AppDomNodeOfType<AllowedChildTypesOf<N>[K]>[] : never;
};

/**
 * Make a copy of a subtree (a fragment) of the dom. The structure of a fragment is
 * the same as a dom where the root is the node we create the fragment for
 */
export declare function cloneFragment(dom: AppDom, nodeId: NodeId): AppDom;

declare type CombinedAllowedChildren = {
    [K in AppDomNodeType]: CombinedChildrenOfType<K>;
};

declare type CombinedChildrenOfType<T extends AppDomNodeType> = AllowedChildren[T][keyof AllowedChildren[T]];

export declare function compareFractionalIndex(index1: string, index2: string): number;

declare interface ComponentConfig<P extends object = {}> {
    /**
     * A short explanatory text that'll be shown in the editor UI when this component is referenced.
     * May contain Markdown.
     */
    helperText?: string;
    /**
     * Configures which properties result in propagating error state to `errorProp`.
     */
    errorPropSource?: (keyof P & string)[];
    /**
     * Designates a property as "the error property". If Toolpad detects an error
     * on any of the inputs, it will forward it to this property.
     */
    errorProp?: keyof P & string;
    /**
     * Configures which properties result in propagating loading state to `loadingProp`.
     */
    loadingPropSource?: (keyof P & string)[];
    /**
     * Designates a property as "the loading property". If Toolpad detects any of the
     * inputs is still loading it will set this property to `true`.
     */
    loadingProp?: keyof P & string;
    /**
     * Enables controlling the aligment of the component container box.
     */
    layoutDirection?: 'vertical' | 'horizontal' | 'both';
    /**
     * Designates a property as "the resizable height property". If Toolpad detects any
     * vertical resizing of the component it will forward it to this property.
     */
    resizableHeightProp?: keyof P & string;
    /**
     * Describes the individual properties for this component.
     */
    argTypes?: ArgTypeDefinitions<P>;
}
export { ComponentConfig }
export { ComponentConfig as ComponentConfig_alias_1 }

declare interface ComponentDefinition<P extends object = {}> {
    argTypes?: ArgTypeDefinitions<P>;
}
export { ComponentDefinition }
export { ComponentDefinition as ComponentDefinition_alias_1 }

declare type Components = ToolpadComponents;
export { Components }
export { Components as Components_alias_1 }

declare const ComponentsContext: React_2.Context<Partial<Record<string, ToolpadComponent<any>>> | null>;
export { ComponentsContext }
export { ComponentsContext as ComponentsContext_alias_1 }

export declare const ComponentsContextProvider: React_2.ComponentType<React_2.ProviderProps<Partial<Record<string, ToolpadComponent<any>>>>>;

declare const ComponentsContextProvider_2: React_2.ComponentType<React_2.ProviderProps<Partial<Record<string, ToolpadComponent<any>>>>>;
export { ComponentsContextProvider_2 as ComponentsContextProvider_alias_1 }
export { ComponentsContextProvider_2 as ComponentsContextProvider_alias_2 }

export declare interface ConnectionNode<P = unknown> extends AppDomNodeBase {
    readonly type: 'connection';
    readonly attributes: {
        readonly dataSource: string;
        readonly params: SecretAttrValue<P | null>;
        readonly status: ConnectionStatus | null;
    };
}

export declare interface ConnectionStatus {
    timestamp: number;
    error?: string;
}

/**
 * Marks the wrapped React component as a Toolpad compatible component.
 * This makes it available in the Toolpad editor.
 * Optionally, you can pass a configuration object to specify the component's argument types.
 * Argument types define the properties that can be set in the Toolpad editor for this component.
 * Additionally, you'll be able to bind page state to these properties.
 * @param Component The React component to wrap.
 * @param config The configuration for the component.
 */
declare function createComponent<P extends object>(Component: React.ComponentType<P>, config?: ComponentConfig<P>): ToolpadComponent<P>;
export { createComponent }
export { createComponent as createComponent_alias_1 }

/**
 * Create a Toolpad data provider. Data providers act as a bridge between Toolpad and your data.
 *
 * Demos:
 *
 * - [Data providers](https://mui.com/toolpad/concepts/data-providers/)
 *
 * API:
 *
 * - [`createDataProvider` API](https://mui.com/toolpad/reference/api/create-data-provider/)
 *
 */
export declare function createDataProvider<R extends Record<string, unknown>, P extends PaginationMode = 'index'>(input: ToolpadDataProviderBase<R, P>): ToolpadDataProvider<R, P>;

export declare function createDefaultDom(): AppDom;

/**
 * Compare two doms and return a diff of the changes.
 */
export declare function createDiff(from: AppDom, to: AppDom): DomDiff;

export declare function createDom(): AppDom;

/**
 * Creates a new DOM node representing a React Element
 */
export declare function createElement<P>(dom: AppDom, component: string, props?: Partial<BindableAttrValues<P>>, layout?: Partial<BindableAttrValues<P>>, name?: string): ElementNode;

export declare function createFormat(dateFormat?: DateFormat): Intl.DateTimeFormat;

export declare function createFormat_alias_1(numberFormat?: NumberFormat): Intl.NumberFormat;

export declare function createFractionalIndex(index1: string | null, index2: string | null): string;

export declare function createFragment<T extends AppDomNodeType>(type: T, init: AppDomNodeInitOfType<T> & {
    name: string;
}): AppDom;

/**
 * @deprecated Directly export a function instead. This will be removed in a future release.
 * See: https://mui.com/toolpad/reference/api/create-function/
 * Use this to define a function that will load the data for a Toolpad query.
 * You can define parameters for the function in the configuration object.
 * These parameters will be available in the Toolpad editor when creating a query and can be bound to page state.
 * The return value of this function will appear as state on the page and can be bound to.
 * @param resolver The function that will load the data for the query.
 * @param config The configuration for the function.
 * override: Config
 */
export declare function createFunction<C extends CreateFunctionConfig<CreateFunctionConfigParameters<C>>, R>(resolver: FunctionResolver<C, R>, config?: C): FunctionResolver<C, R> & {
    [TOOLPAD_FUNCTION]: C | {
        parameters: {};
    };
};

/**
 * The runtime configuration for a Toolpad function. Describes the parameters it accepts and their
 * corresponding types.
 */
export declare interface CreateFunctionConfig<C> {
    parameters: {
        [K in keyof C]: PrimitiveValueType;
    };
}

declare type CreateFunctionConfigParameters<C extends CreateFunctionConfig<CreateFunctionConfigParameters<C>>> = FunctionResolverParams<C>['parameters'];

export declare function createId(): NodeId;

export declare function createNode<T extends AppDomNodeType>(dom: AppDom, type: T, init: AppDomNodeInitOfType<T>): AppDomNodeOfType<T>;

/**
 * @deprecated
 * createQuery is deprecated. Use createFunction instead.
 */
export declare const createQuery: typeof createFunction;

/**
 * We need to make sure no secrets end up in the frontend html, so let's only send the
 * nodes that we need to build frontend, and that we know don't contain secrets.
 * TODO: Would it make sense to create a separate datastructure that represents the render tree?
 */
export declare function createRenderTree(dom: AppDom): RenderTree;

export declare function createSecret<V>(value: V): SecretAttrValue<V>;

export declare function createServerContext(req: IncomingMessage, res: ServerResponse): Promise<ServerContext>;

export declare function createServerJsRuntime(env?: Record<string, string | undefined>): JsRuntime;

declare function createToolpadComponentThatThrows(error: Error): ToolpadComponent<object>;
export { createToolpadComponentThatThrows }
export { createToolpadComponentThatThrows as createToolpadComponentThatThrows_alias_1 }

export declare const CURRENCY_CODES_LIST_HELP_URL = "https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes";

export declare const CURRENT_APPDOM_VERSION = 7;

declare interface CursorPaginationModel {
    cursor: string | null;
    pageSize: number;
}
export { CursorPaginationModel }
export { CursorPaginationModel as CursorPaginationModel_alias_1 }

export declare const DATE_STYLES: Map<"full" | "long" | "medium" | "short" | undefined, DateFormatPreset>;

export declare interface DateFormat {
    kind: 'shorthand';
    dateStyle?: DateStyle;
    timeStyle?: TimeStyle;
}

export declare function DateFormatEditor({ label, disabled, value, onChange, sx, disableTimeFormat, }: DateFormatEditorProps): React_2.JSX.Element;

export declare interface DateFormatEditorProps {
    value?: DateFormat;
    onChange: (newValue?: DateFormat) => void;
    disabled?: boolean;
    sx?: SxProps;
    label?: string;
    disableTimeFormat?: boolean;
}

export declare interface DateFormatPreset {
    label?: string;
}

export declare type DateStyle = Intl.DateTimeFormatOptions['dateStyle'];

export declare function deref(nodeRef: NodeReference): NodeId;

export declare function deref(nodeRef: null | undefined): null;

export declare function deref(nodeRef: Maybe<NodeReference>): NodeId | null;

/**
 * Represents the changes between two doms in terms of added/deleted nodes.
 */
export declare interface DomDiff {
    set: AppDomNode[];
    unset: NodeId[];
}

export declare function duplicateNode(dom: AppDom, node: AppDomNode, parent?: AppDomNode | null, parentProp?: string | null): AppDom;

export declare interface ElementNode<P = any> extends AppDomNodeBase {
    readonly type: 'element';
    readonly attributes: {
        readonly component: string;
    };
    readonly props?: BindableAttrValues<P>;
    readonly layout?: {
        readonly horizontalAlign?: BoxProps['justifyContent'];
        readonly verticalAlign?: BoxProps['alignItems'];
        readonly columnSize?: number;
    };
}

declare interface ElementValueType extends ValueTypeBase {
    /**
     * the property is a React.ReactNode.
     */
    type: 'element';
}
export { ElementValueType }
export { ElementValueType as ElementValueType_alias_1 }

declare interface EnvAttrValue {
    $$env: string;
}
export { EnvAttrValue }
export { EnvAttrValue as EnvAttrValue_alias_1 }

export declare function evaluateBindable<V>(ctx: JsRuntime, bindable: BindableAttrValue<V> | null, globalScope: Record<string, unknown>): BindingEvaluationResult;

declare interface EventValueType extends ValueTypeBase {
    /**
     * the property is an event handler.
     */
    type: 'event';
    /**
     * Description of the handler's arguments.
     */
    arguments?: {
        /**
         * The argument's name.
         */
        name: string;
        /**
         * The argument's type.
         */
        tsType: string;
    }[];
}
export { EventValueType }
export { EventValueType as EventValueType_alias_1 }

declare type ExecFetchResult<T = any> = {
    data?: T;
    error?: SerializedError;
};
export { ExecFetchResult }
export { ExecFetchResult as ExecFetchResult_alias_1 }

export declare type FetchMode = 'query' | 'mutation';

declare interface FilterModel {
    items: FilterModelItem[];
    logicOperator: LogicOperator;
}
export { FilterModel }
export { FilterModel as FilterModel_alias_1 }

declare interface FilterModelItem {
    field: string;
    operator: string;
    value: unknown;
}
export { FilterModelItem }
export { FilterModelItem as FilterModelItem_alias_1 }

export declare type FlowDirection = 'row' | 'column' | 'row-reverse' | 'column-reverse';

export declare type FlowDirection_alias_1 = 'row' | 'column' | 'row-reverse' | 'column-reverse';

export declare function FormattedDate({ children, format }: FormattedDateProps): React_2.JSX.Element;

export declare interface FormattedDateProps {
    format?: Intl.DateTimeFormat;
    children: Date | number;
}

export declare function FormattedNumber({ children, format }: FormattedNumberProps): React_2.JSX.Element;

export declare interface FormattedNumberProps {
    format?: Intl.NumberFormat;
    children: number | string;
}

export declare function fromConstPropValue(prop: undefined): undefined;

export declare function fromConstPropValue<T>(prop: BindableAttrValue<T>): T;

export declare function fromConstPropValue<T>(prop?: BindableAttrValue<T | undefined>): T | undefined;

export declare function fromConstPropValues<P>(props: BindableAttrValues<P>): Partial<P>;

export declare interface FunctionResolver<C extends CreateFunctionConfig<CreateFunctionConfigParameters<C>>, R> {
    (params: FunctionResolverParams<C>): Promise<R>;
}

export declare interface FunctionResolverParams<C extends CreateFunctionConfig<CreateFunctionConfigParameters<C>>> {
    parameters: {
        [K in keyof C['parameters']]: InferParameterType<C['parameters'][K]>;
    };
}

export declare function getAncestors(dom: AppDom, node: AppDomNode): readonly AppDomNode[];

export declare function getApp(dom: AppDom): AppNode;

declare function getArgTypeDefaultValue<P extends object, K extends keyof P>(argType: ArgTypeDefinition<P, K>): P[K] | undefined;
export { getArgTypeDefaultValue }
export { getArgTypeDefaultValue as getArgTypeDefaultValue_alias_1 }

export declare function getBrowserRuntime(): JsRuntime;

export declare function getChildNodes<N extends AppDomNode>(dom: AppDom, parent: N): NodeChildren<N>;

/**
 * Returns all nodes with a given component type
 */
export declare function getComponentTypeNodes(dom: AppDom, componentId: string): readonly AppDomNode[];

/**
 * Interact with the server context of a Toolpad application.
 * This function is only callable from within a Toolpad function.
 *
 * Demos:
 *
 * - [Custom Functions](https://mui.com/toolpad/concepts/custom-functions/#request-context/)
 *
 * API:
 *
 * - [`getContext` API](https://mui.com/toolpad/reference/api/get-context)
 *
 */
export declare function getContext(): ServerContext;

/**
 * Get all descendants of a `node`, flattens childNodes objects into one single array
 */
export declare function getDescendants(dom: AppDom, node: AppDomNode): readonly AppDomNode[];

export declare function getExistingNamesForChildren<Parent extends AppDomNode>(dom: AppDom, parent: Parent, parentProp?: ParentProp<Parent>): Set<string>;

/**
 * Returns the set of names for which the given node must have a different name
 */
export declare function getExistingNamesForNode(dom: AppDom, node: AppDomNode): Set<string>;

export declare function getMaybeNode<T extends AppDomNodeType>(dom: AppDom, nodeId: NodeId, type: T): AppDomNodeOfType<T> | null;

export declare function getMaybeNode<T extends AppDomNodeType>(dom: AppDom, nodeId: NodeId, type?: T): AppDomNode | null;

export declare function getNewFirstParentIndexInNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): string;

export declare function getNewLastParentIndexInNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): string;

export declare function getNewParentIndexAfterNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): string;

export declare function getNewParentIndexBeforeNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): string;

export declare function getNode<T extends AppDomNodeType>(dom: AppDom, nodeId: NodeId, type: T): AppDomNodeOfType<T>;

export declare function getNode<T extends AppDomNodeType>(dom: AppDom, nodeId: NodeId, type?: T): AppDomNode;

export declare function getNodeFirstChild(dom: AppDom, node: ElementNode | PageNode, parentProp: string): ElementNode<any> | null;

export declare function getNodeLastChild(dom: AppDom, node: ElementNode | PageNode, parentProp: string): ElementNode<any> | null;

/**
 * Get the first PageNode node up in the DOM tree starting from `node`
 */
export declare function getPageAncestor(dom: AppDom, node: AppDomNode): PageNode | null;

/**
 * Get all the ancestors of the `node` up until the first PageNode node is encountered
 */
export declare function getPageAncestors(dom: AppDom, node: AppDomNode): readonly (ElementNode | PageNode)[];

export declare function getPageByName(dom: AppDom, name: string): PageNode | null;

export declare function getPageDisplayName(node: PageNode): string;

export declare function getPageForAlias(dom: AppDom, alias: string): string | null;

export declare function getPageTitle(node: PageNode): string;

export declare function getParent<N extends AppDomNode>(dom: AppDom, child: N): ParentOf<N>;

export declare function getPlan(dom: AppDom): ToolpadPlan;

export declare function getQueryByName(dom: AppDom, page: PageNode, name: string): QueryNode | null;

declare interface GetRecordsParams<R, P extends PaginationMode> {
    paginationModel: PaginationModel<P>;
    filterModel: FilterModel;
    sortModel: SortModel;
}
export { GetRecordsParams }
export { GetRecordsParams as GetRecordsParams_alias_1 }

declare interface GetRecordsResult<R, P extends PaginationMode> {
    records: R[];
    hasNextPage?: boolean;
    totalCount?: number;
    cursor?: P extends 'cursor' ? string | null : undefined;
}
export { GetRecordsResult }
export { GetRecordsResult as GetRecordsResult_alias_1 }

export declare function getRoot(dom: AppDom): AppDomNode;

export declare function getServerContext(): ServerContext | undefined;

export declare function getSiblingAfterNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): ElementNode<any> | null;

export declare function getSiblingBeforeNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): ElementNode<any> | null;

/**
 * Get all siblings of a `node`
 */
export declare function getSiblings(dom: AppDom, node: AppDomNode): readonly AppDomNode[];

export declare function getUserToken(req: express.Request): Promise<JWT | null>;

declare const IMAGE_EXTENSIONS: string[];
export { IMAGE_EXTENSIONS }
export { IMAGE_EXTENSIONS as IMAGE_EXTENSIONS_alias_1 }

declare interface IndexPaginationModel {
    start: number;
    pageSize: number;
}
export { IndexPaginationModel }
export { IndexPaginationModel as IndexPaginationModel_alias_1 }

declare type InferParameterType<T extends PropValueType> = T extends {
    type: 'object' | 'array';
    schema: JSONSchema7;
} ? JsonSchemaToTs<T['schema']> : ParameterTypeLookup[NonNullable<T['type']>];
export { InferParameterType }
export { InferParameterType as InferParameterType_alias_1 }

export declare function isApp(node: AppDomNode): node is AppNode;

export declare function isCodePage(node: PageNode): boolean;

export declare function isConnection<P>(node: AppDomNode): node is ConnectionNode<P>;

export declare function isElement<P>(node: AppDomNode): node is ElementNode<P>;

export declare function isMutation<P>(node: AppDomNode): node is MutationNode<P>;

export declare function isPage(node: AppDomNode): node is PageNode;

export declare function isQuery<P>(node: AppDomNode): node is QueryNode<P>;

export declare function isTheme(node: AppDomNode): node is ThemeNode;

declare function isToolpadComponent(maybeComponent: unknown): maybeComponent is ToolpadComponent<any>;
export { isToolpadComponent }
export { isToolpadComponent as isToolpadComponent_alias_1 }

declare interface JsExpressionAction {
    $$jsExpressionAction: string;
}
export { JsExpressionAction }
export { JsExpressionAction as JsExpressionAction_alias_1 }

declare interface JsExpressionAttrValue {
    $$jsExpression: string;
}
export { JsExpressionAttrValue }
export { JsExpressionAttrValue as JsExpressionAttrValue_alias_1 }

declare type JsonSchemaToTs<T extends JSONSchema7> = T extends {
    type: 'object';
    properties?: Record<string, JSONSchema7>;
} ? {
    [K in keyof T['properties']]?: JsonSchemaToTs<NonNullable<T['properties']>[K]>;
} : T extends {
    type: 'array';
    items?: JSONSchema7;
} ? T['items'] extends undefined ? unknown[] : JsonSchemaToTs<NonNullable<T['items']>>[] : T extends {
    type: 'string';
} ? string : T extends {
    type: 'number' | 'integer';
} ? number : T extends {
    type: 'boolean';
} ? boolean : T extends {
    type: 'null';
} ? null : unknown;
export { JsonSchemaToTs }
export { JsonSchemaToTs as JsonSchemaToTs_alias_1 }

declare interface JsRuntime {
    getEnv(): Record<string, string | undefined>;
    evaluateExpression(code: string, globalScope: Record<string, unknown>): BindingEvaluationResult;
}
export { JsRuntime }
export { JsRuntime as JsRuntime_alias_1 }

declare type LiveBinding = BindingEvaluationResult;
export { LiveBinding }
export { LiveBinding as LiveBinding_alias_1 }

declare interface LiveBindingError {
    message: string;
    stack?: string;
}
export { LiveBindingError }
export { LiveBindingError as LiveBindingError_alias_1 }

declare type LiveBindings = Partial<Record<string, LiveBinding>>;
export { LiveBindings }
export { LiveBindings as LiveBindings_alias_1 }

declare type LogicOperator = 'and' | 'or';
export { LogicOperator }
export { LogicOperator as LogicOperator_alias_1 }

export declare function moveNode<Parent extends AppDomNode, Child extends AppDomNode>(dom: AppDom, node: Child, parent: Parent, parentProp: ParentPropOf<Child, Parent>, parentIndex?: string): AppDom;

/**
 * @deprecated QueryNode can act as a mutation by switching the `mode` attribute to 'mutation'
 */
export declare interface MutationNode<Q = any> extends AppDomNodeBase {
    readonly type: 'mutation';
    readonly params?: BindableAttrValues;
    readonly attributes: {
        readonly dataSource?: string;
        readonly connectionId: NodeReference | null;
        readonly query: Q;
    };
}

declare interface NavigationAction<P = any> {
    $$navigationAction: {
        page: string;
        parameters?: BindableAttrValues<P>;
    };
}
export { NavigationAction }
export { NavigationAction as NavigationAction_alias_1 }

declare type NestedBindableAttrs = BindableAttrValue<any> | BindableAttrValues<any> | [string, BindableAttrValue<any>][];
export { NestedBindableAttrs }
export { NestedBindableAttrs as NestedBindableAttrs_alias_1 }

export declare type NodeChildren<N extends AppDomNode = any> = ChildNodesOf<N>;

declare interface NodeErrorProps {
    error: RuntimeError;
}
export { NodeErrorProps }
export { NodeErrorProps as NodeErrorProps_alias_1 }

export declare function nodeExists(dom: AppDom, nodeId: NodeId): boolean;

declare type NodeHashes = Record<NodeId, number | undefined>;
export { NodeHashes }
export { NodeHashes as NodeHashes_alias_1 }

declare type NodeId = Branded<string, 'NodeId'>;
export { NodeId }
export { NodeId as NodeId_alias_1 }

declare interface NodeReference {
    $ref: NodeId;
}
export { NodeReference }
export { NodeReference as NodeReference_alias_1 }

declare interface NodeRuntime<P> {
    nodeId: string | null;
    nodeName: string | null;
    updateAppDomConstProp: <K extends keyof P & string>(key: K, value: React_2.SetStateAction<P[K]>) => void;
    updateEditorNodeData: (key: string, value: any) => void;
}
export { NodeRuntime }
export { NodeRuntime as NodeRuntime_alias_1 }

export declare const NodeRuntimeContext: React_2.Context<{
    nodeId: NodeId | null;
    nodeName: string | null;
}>;

export declare function NodeRuntimeWrapper({ nodeId, nodeName, children, NodeError, }: NodeRuntimeWrapperProps): React_2.JSX.Element;

export declare interface NodeRuntimeWrapperProps {
    children: React_2.ReactElement;
    nodeId: NodeId;
    nodeName: string;
    NodeError: React_2.ComponentType<NodeErrorProps>;
}

export declare const NUMBER_FORMAT_PRESETS: Map<string, NumberFormatPreset>;

export declare const NUMBER_FORMAT_SCHEMA: JSONSchema7;

export declare type NumberFormat = {
    kind: 'preset';
    preset: string;
} | {
    kind: 'currency';
    currency?: string;
} | {
    kind: 'custom';
    custom: Intl.NumberFormatOptions;
};

export declare function NumberFormatEditor({ label, disabled, value, onChange, sx, }: NumberFormatEditorProps): React_2.JSX.Element;

export declare interface NumberFormatEditorProps {
    value?: NumberFormat;
    onChange: (newValue?: NumberFormat) => void;
    disabled?: boolean;
    sx?: SxProps;
    label?: string;
}

export declare interface NumberFormatPreset {
    label?: string;
    options?: Intl.NumberFormatOptions;
}

export declare interface NumberFormatter {
    (params: NumberFormatterParams): string;
}

declare interface NumberFormatterParams {
    value: unknown;
}

declare interface NumberValueType extends ValueTypeBase {
    /**
     * the property is a number.
     */
    type: 'number';
    /**
     * A minimum value for the property.
     */
    minimum?: number;
    /**
     * A maximum value for the property.
     */
    maximum?: number;
    default?: number;
}
export { NumberValueType }
export { NumberValueType as NumberValueType_alias_1 }

declare interface ObjectValueType extends ValueTypeBase {
    /**
     * the property is an object.
     */
    type: 'object';
    /**
     * A JSON schema describing the object.
     */
    schema?: JSONSchema7;
    default?: any;
}
export { ObjectValueType }
export { ObjectValueType as ObjectValueType_alias_1 }

export declare type PageDisplayMode = 'standalone' | 'shell';

export declare interface PageNode extends AppDomNodeBase {
    readonly type: 'page';
    readonly attributes: {
        readonly title?: string;
        readonly alias?: string[];
        readonly parameters?: [string, string][];
        readonly module?: string;
        readonly display?: PageDisplayMode;
        readonly codeFile?: boolean;
        readonly displayName?: string;
        readonly authorization?: {
            readonly allowAll?: boolean;
            readonly allowedRoles?: string[];
        };
    };
}

declare type PaginationMode = 'index' | 'cursor';
export { PaginationMode }
export { PaginationMode as PaginationMode_alias_1 }

declare type PaginationModel<M extends PaginationMode = PaginationMode> = M extends 'cursor' ? CursorPaginationModel : IndexPaginationModel;
export { PaginationModel }
export { PaginationModel as PaginationModel_alias_1 }

declare interface ParameterTypeLookup {
    number: number;
    string: string;
    boolean: boolean;
    array: unknown[];
    object: Record<string, unknown>;
    element: React_2.ReactNode;
    template: () => React_2.ReactNode;
    event: (...args: any[]) => void;
}
export { ParameterTypeLookup }
export { ParameterTypeLookup as ParameterTypeLookup_alias_1 }

export declare type ParentOf<N extends AppDomNode> = AppDomNodeOfType<ParentTypeOfType<TypeOf<N>>> | null;

export declare type ParentProp<Parent extends AppDomNode> = keyof AllowedChildTypesOfType<TypeOf<Parent>>;

export declare type ParentPropOf<Child extends AppDomNode, Parent extends AppDomNode> = {
    [K in keyof AllowedChildren[TypeOf<Parent>]]: TypeOf<Child> extends AllowedChildren[TypeOf<Parent>][K] ? K & string : never;
}[keyof AllowedChildren[TypeOf<Parent>]];

declare type ParentTypeOfType<T extends AppDomNodeType> = {
    [K in AppDomNodeType]: T extends CombinedAllowedChildren[K] ? K : never;
}[AppDomNodeType];

declare function Placeholder({ prop, children }: PlaceholderProps): React_2.JSX.Element;
export { Placeholder }
export { Placeholder as Placeholder_alias_1 }

declare interface PlaceholderProps {
    prop: string;
    children?: React_2.ReactNode;
}
export { PlaceholderProps }
export { PlaceholderProps as PlaceholderProps_alias_1 }

export declare type PrettyNumberFormat = React_2.ComponentType<NumberFormatterParams>;

declare type PrimitiveValueType = StringValueType | NumberValueType | BooleanValueType | ObjectValueType | ArrayValueType;
export { PrimitiveValueType }
export { PrimitiveValueType as PrimitiveValueType_alias_1 }

declare type PropBindableAttrValue<V> = V | JsExpressionAttrValue | EnvAttrValue;
export { PropBindableAttrValue }
export { PropBindableAttrValue as PropBindableAttrValue_alias_1 }

export declare type PropNamespaces<N extends AppDomNode> = {
    [K in keyof N]: N[K] extends BindableAttrValues<any> | undefined ? K : never;
}[keyof N & string];

export declare function proposeName(candidate: string, disallowedNames?: Set<string>): string;

declare type PropValueType = AnyValueType | PrimitiveValueType | ElementValueType | TemplateValueType | EventValueType;
export { PropValueType }
export { PropValueType as PropValueType_alias_1 }

declare type PropValueTypes<K extends string = string> = Partial<{
    [key in K]?: PropValueType;
}>;
export { PropValueTypes }
export { PropValueTypes as PropValueTypes_alias_1 }

/**
 * A DOM query is defined primarily by a server defined part "attributes.query"
 * and a clientside defined part "params". "params" are constructed in the runtime
 * from bound expressions. The resolved object will be sent to the server and combined
 * with the query will be used to collect the data from the backend.
 */
export declare interface QueryNode<Q = any> extends AppDomNodeBase {
    readonly type: 'query';
    readonly params?: BindableAttrEntries;
    readonly attributes: {
        readonly mode?: FetchMode;
        readonly dataSource?: string;
        readonly connectionId: NodeReference | null;
        readonly query: Q;
        readonly transform?: string;
        readonly transformEnabled?: boolean;
        /** @deprecated Not necessary to be user-facing, we will expose staleTime instead if necessary */
        readonly refetchOnWindowFocus?: boolean;
        /** @deprecated Not necessary to be user-facing, we will expose staleTime instead if necessary */
        readonly refetchOnReconnect?: boolean;
        readonly refetchInterval?: number;
        readonly cacheTime?: number;
        readonly enabled?: BindableAttrValue<boolean>;
    };
}

export declare function ref(nodeId: NodeId): NodeReference;

export declare function ref(nodeId: null | undefined): null;

export declare function ref(nodeId: Maybe<NodeId>): NodeReference | null;

export declare function removeMaybeNode(dom: AppDom, nodeId: NodeId): AppDom;

export declare function removeNode(dom: AppDom, nodeId: NodeId): AppDom;

export declare interface RenderTree {
    root: NodeId;
    nodes: RenderTreeNodes;
    version?: number;
}

declare const RENDERTREE_NODES: readonly ["app", "page", "element", "query", "mutation", "theme"];

export declare type RenderTreeNode = {
    [K in RenderTreeNodeType]: AppDomNodeOfType<K>;
}[RenderTreeNodeType];

export declare type RenderTreeNodes = Record<NodeId, RenderTreeNode>;

export declare type RenderTreeNodeType = (typeof RENDERTREE_NODES)[number];

export declare const RESERVED_NODE_PROPERTIES: readonly ["id", "type", "parentId", "parentProp", "parentIndex"];

export declare type ReservedNodeProperty = (typeof RESERVED_NODE_PROPERTIES)[number];

export declare const ResetNodeErrorsKeyProvider: React_2.Provider<number>;

declare interface RuntimeError {
    message: string;
    stack?: string;
}
export { RuntimeError }
export { RuntimeError as RuntimeError_alias_1 }

declare type RuntimeEvent = {
    [K in keyof RuntimeEvents]: {
        type: K;
    } & RuntimeEvents[K];
}[keyof RuntimeEvents];
export { RuntimeEvent }
export { RuntimeEvent as RuntimeEvent_alias_1 }

declare type RuntimeEvents = {
    propUpdated: {
        nodeId: string;
        prop: string;
        value: React_2.SetStateAction<unknown>;
    };
    editorNodeDataUpdated: {
        nodeId: NodeId;
        prop: string;
        value: any;
    };
    pageStateUpdated: {
        pageState: Record<string, unknown>;
        globalScopeMeta: ScopeMeta;
    };
    pageBindingsUpdated: {
        bindings: LiveBindings;
    };
    screenUpdate: {};
    ready: {};
    pageNavigationRequest: {
        pageName: string;
    };
    vmUpdated: {
        vm: ApplicationVm;
    };
};
export { RuntimeEvents }
export { RuntimeEvents as RuntimeEvents_alias_1 }

declare interface RuntimeScope {
    id: string;
    parentScope?: RuntimeScope;
    bindings: Record<string, BindingEvaluationResult<unknown>>;
    values: Record<string, unknown>;
    meta: ScopeMeta;
}
export { RuntimeScope }
export { RuntimeScope as RuntimeScope_alias_1 }

export declare function saveNode(dom: AppDom, node: AppDomNode): AppDom;

declare type ScopeMeta = Partial<Record<string, ScopeMetaField>>;
export { ScopeMeta }
export { ScopeMeta as ScopeMeta_alias_1 }

declare type ScopeMetaField = {
    description?: string;
    deprecated?: boolean | string;
    tsType?: string;
} & ({
    kind?: undefined;
} | {
    kind: 'element';
    componentId: string;
    props?: Record<string, ScopeMetaPropField>;
} | {
    kind: 'query' | 'action' | 'local';
});
export { ScopeMetaField }
export { ScopeMetaField as ScopeMetaField_alias_1 }

declare interface ScopeMetaPropField {
    tsType?: string;
}
export { ScopeMetaPropField }
export { ScopeMetaPropField as ScopeMetaPropField_alias_1 }

declare interface SecretAttrValue<V> {
    $$secret: V;
}
export { SecretAttrValue }
export { SecretAttrValue as SecretAttrValue_alias_1 }

declare type Serializable = string | number | boolean | null | undefined | Serializable[] | {
    [key: string]: Serializable;
} | ((...args: Serializable[]) => Serializable);
export { Serializable }
export { Serializable as Serializable_alias_1 }

declare interface ServerContext {
    /**
     * A dictionary mapping cookie name to cookie value.
     */
    cookies: Record<string, string>;
    /**
     * Use to set a cookie `name` with `value`.
     */
    setCookie: (name: string, value: string) => void;
    /**
     * Data about current authenticated session.
     */
    session: {
        user: ServerContextSessionUser;
    } | null;
}
export { ServerContext }
export { ServerContext as ServerContext_alias_1 }

declare interface ServerContextSessionUser {
    name?: string | null;
    email?: string | null;
    avatar?: string | null;
    roles?: string[];
}

export declare function setNamespacedProp<Node extends AppDomNode, Namespace extends PropNamespaces<Node>, Prop extends keyof Node[Namespace] & string>(node: Node, namespace: Namespace, prop: Prop, value: Node[Namespace][Prop] | null): Node;

export declare function setNodeName(dom: AppDom, node: AppDomNode, name: string): AppDom;

export declare function setNodeNamespacedProp<Node extends AppDomNode, Namespace extends PropNamespaces<Node>, Prop extends keyof NonNullable<Node[Namespace]> & string>(dom: AppDom, node: Node, namespace: Namespace, prop: Prop, value: NonNullable<Node[Namespace]>[Prop]): AppDom;

export declare function setNodeProp<Node extends AppDomNode, Prop extends BindableProps<Node>>(dom: AppDom, node: Node, prop: Prop, value: Node[Prop] | null): AppDom;

export declare function setQueryProp<Q, K extends keyof Q>(node: QueryNode<Q>, prop: K, value: Q[K]): QueryNode<Q>;

declare function Slots({ prop, children, hasLayout }: SlotsProps): React_2.JSX.Element;
export { Slots }
export { Slots as Slots_alias_1 }

declare interface SlotsProps {
    prop: string;
    children?: React_2.ReactNode;
    hasLayout?: boolean;
}
export { SlotsProps }
export { SlotsProps as SlotsProps_alias_1 }

declare type SlotType = 'single' | 'multiple' | 'layout';
export { SlotType }
export { SlotType as SlotType_alias_1 }

declare type SortDirection = 'asc' | 'desc';
export { SortDirection }
export { SortDirection as SortDirection_alias_1 }

declare interface SortItem {
    field: string;
    sort: SortDirection;
}
export { SortItem }
export { SortItem as SortItem_alias_1 }

declare type SortModel = SortItem[];
export { SortModel }
export { SortModel as SortModel_alias_1 }

declare interface StringValueType extends ValueTypeBase {
    /**
     * the property is a string.
     */
    type: 'string';
    /**
     * The different possible values for the property.
     */
    enum?: string[];
    enumLabels?: Record<string, string>;
    default?: string;
}
export { StringValueType }
export { StringValueType as StringValueType_alias_1 }

declare type TemplateRenderer = (scopeKey: string, params: Record<string, unknown>) => React_2.ReactNode;
export { TemplateRenderer }
export { TemplateRenderer as TemplateRenderer_alias_1 }

declare interface TemplateValueType extends ValueTypeBase {
    /**
     * the property is a render function.
     */
    type: 'template';
}
export { TemplateValueType }
export { TemplateValueType as TemplateValueType_alias_1 }

export declare interface ThemeNode extends AppDomNodeBase {
    readonly type: 'theme';
    readonly theme?: ThemeOptions;
}

export declare const TIME_STYLES: Map<"full" | "long" | "medium" | "short" | undefined, DateFormatPreset>;

export declare type TimeStyle = Intl.DateTimeFormatOptions['timeStyle'];

declare const TOOLPAD_COMPONENT: unique symbol;
export { TOOLPAD_COMPONENT }
export { TOOLPAD_COMPONENT as TOOLPAD_COMPONENT_alias_1 }

declare const TOOLPAD_COMPONENT_MODE_PROPERTY = "ToolpadComponentMode";
export { TOOLPAD_COMPONENT_MODE_PROPERTY }
export { TOOLPAD_COMPONENT_MODE_PROPERTY as TOOLPAD_COMPONENT_MODE_PROPERTY_alias_1 }

export declare const TOOLPAD_DATA_PROVIDER_MARKER: unique symbol;

declare const TOOLPAD_FUNCTION: unique symbol;
export { TOOLPAD_FUNCTION }
export { TOOLPAD_FUNCTION as TOOLPAD_FUNCTION_alias_1 }

export declare const TOOLPAD_LOADING_MARKER = "__TOOLPAD_LOADING_MARKER__";

declare type ToolpadComponent<P extends object = {}> = React_2.ComponentType<P> & {
    [TOOLPAD_COMPONENT]: ComponentConfig<P>;
};
export { ToolpadComponent }
export { ToolpadComponent as ToolpadComponent_alias_1 }

declare type ToolpadComponents = Partial<Record<string, ToolpadComponent<any>>>;
export { ToolpadComponents }
export { ToolpadComponents as ToolpadComponents_alias_1 }

export declare interface ToolpadDataProvider<R extends Record<string, unknown>, P extends PaginationMode = 'index'> extends ToolpadDataProviderBase<R, P> {
    [TOOLPAD_DATA_PROVIDER_MARKER]: true;
}

declare interface ToolpadDataProviderBase<R extends Record<string, unknown> = {}, P extends PaginationMode = 'index'> {
    paginationMode?: P;
    getRecords: (params: GetRecordsParams<R, P>) => Promise<GetRecordsResult<R, P>>;
    deleteRecord?: (id: string | number) => Promise<void>;
    updateRecord?: (id: string | number, record: Partial<R>) => Promise<R | void>;
    createRecord?: (record: R) => Promise<R>;
}
export { ToolpadDataProviderBase }
export { ToolpadDataProviderBase as ToolpadDataProviderBase_alias_1 }

export declare interface ToolpadDataProviderIntrospection {
    paginationMode: PaginationMode;
    hasDeleteRecord: boolean;
    hasUpdateRecord: boolean;
    hasCreateRecord: boolean;
}

export declare interface ToolpadFunction<C extends CreateFunctionConfig<CreateFunctionConfigParameters<C>>, R> extends FunctionResolver<C, R> {
    [TOOLPAD_FUNCTION]: C;
}

declare type ToolpadPlan = 'free' | 'pro' | undefined;

declare type TypeOf<N extends AppDomNode> = N['type'];

export declare function useBrowserJsRuntime(): JsRuntime;

export declare function useComponent(id: string): ToolpadComponent<any> | ToolpadComponent<object>;

declare function useComponent_2(id: string): ToolpadComponent<any> | ToolpadComponent<object>;
export { useComponent_2 as useComponent_alias_1 }
export { useComponent_2 as useComponent_alias_2 }

export declare const useComponents: () => Partial<Record<string, ToolpadComponent<any>>>;

declare const useComponents_2: () => Partial<Record<string, ToolpadComponent<any>>>;
export { useComponents_2 as useComponents_alias_1 }
export { useComponents_2 as useComponents_alias_2 }

declare const UseDataProviderContext: React_2.Context<UseDataProviderHook | null>;
export { UseDataProviderContext }
export { UseDataProviderContext as UseDataProviderContext_alias_1 }

export declare interface UseDataProviderHook {
    <R extends Record<string, unknown>, P extends PaginationMode>(id: string | null): UseDataProviderHookResult<R, P>;
}

export declare interface UseDataProviderHookResult<R extends Record<string, unknown>, P extends PaginationMode> {
    isLoading: boolean;
    error?: unknown;
    dataProvider: ToolpadDataProviderBase<R, P> | null;
}

declare function useNode<P = {}>(): NodeRuntime<P> | null;
export { useNode }
export { useNode as useNode_alias_1 }

export declare function useServerJsRuntime(): JsRuntime;

declare function useUrlQueryState(param: string, defaultValue?: string): [string, React_2.Dispatch<React_2.SetStateAction<string>>];
export { useUrlQueryState as default_alias }
export { useUrlQueryState }

export declare function validateNodeName(name: string, disallowedNames: Set<string>, kind: string): string | null;

declare interface ValueTypeBase {
    /**
     * Specifies the type of the value.
     */
    type?: 'string' | 'boolean' | 'number' | 'object' | 'array' | 'element' | 'template' | 'event';
    /**
     * A default value for the property.
     */
    default?: unknown;
    /**
     * A short explanatory text that'll be shown in the editor UI when this property is referenced.
     * May contain Markdown.
     */
    helperText?: string;
}
export { ValueTypeBase }
export { ValueTypeBase as ValueTypeBase_alias_1 }

export declare function withContext<R = void>(ctx: ServerContext, doWork: () => Promise<R>): Promise<R>;

export { }
