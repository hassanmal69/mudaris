// src/server/appServerWorker.ts
import { parentPort, workerData } from "worker_threads";
import invariant from "invariant";
import { createRpcClient } from "@mui/toolpad-utils/workerRpc";

// src/server/toolpadAppBuilder.ts
import * as path3 from "path";
import * as url from "node:url";
import * as fs from "fs";
import react from "@vitejs/plugin-react";
import { indent } from "@mui/toolpad-utils/strings";
import * as appDom from "@mui/toolpad-core/appDom";

// src/constants.ts
var RUNTIME_CONFIG_WINDOW_PROPERTY = "__TOOLPAD_RUNTIME_CONFIG__";
var INITIAL_STATE_WINDOW_PROPERTY = "__initialToolpadState__";
var VERSION_CHECK_INTERVAL = 1e3 * 60 * 10;

// src/utils/paths.ts
import * as path from "path";
function toPosixPath(importPath) {
  return path.normalize(importPath).split(path.sep).join(path.posix.sep);
}
function pathToNodeImportSpecifier(importPath) {
  const normalized = toPosixPath(importPath);
  return normalized.startsWith("/") || normalized.startsWith(".") ? normalized : `./${normalized}`;
}

// src/server/viteVirtualPlugin.ts
import { posix as path2 } from "path";
import { transformWithEsbuild } from "vite";
var API_PROPERTY = Symbol("virtual-fs-api");
function virtualFsPlugin(initialFiles, userIdentifier) {
  const prefix = `virtual:${userIdentifier}:`;
  const resolvedPrefix = `\0${prefix}`;
  const transformExtensions = /* @__PURE__ */ new Set([".js", ".jsx", ".ts", ".tsx"]);
  const resolveExtensions = /* @__PURE__ */ new Set([".js", ".jsx", ".ts", ".tsx", ".json"]);
  let serverInstance;
  let files = initialFiles;
  return {
    name: "virtual-fs",
    enforce: "pre",
    configureServer(server) {
      serverInstance = server;
    },
    resolveId(id, importer) {
      if (id.startsWith(prefix)) {
        const entryPath = id.slice(prefix.length);
        if (files.has(entryPath)) {
          return `${resolvedPrefix}${entryPath}`;
        }
        for (const extension of resolveExtensions) {
          const entryPathWithExtension = `${entryPath}${extension}`;
          if (files.has(entryPathWithExtension)) {
            return `${resolvedPrefix}${entryPathWithExtension}`;
          }
        }
      } else if (importer?.startsWith(resolvedPrefix)) {
        const importerPath = importer.slice(resolvedPrefix.length);
        const fullPath = path2.resolve(path2.dirname(importerPath), id);
        return this.resolve(`${prefix}${fullPath}`, importer);
      }
      return null;
    },
    async load(id) {
      if (id.startsWith(resolvedPrefix)) {
        const virtualPath = id.slice(resolvedPrefix.length);
        const content = files.get(virtualPath);
        return content;
      }
      return null;
    },
    async transform(code, id) {
      if (id.startsWith(resolvedPrefix)) {
        const virtualPath = id.slice(resolvedPrefix.length);
        if (transformExtensions.has(path2.extname(virtualPath))) {
          return transformWithEsbuild(code, virtualPath);
        }
      }
      return null;
    },
    [API_PROPERTY]: {
      async replaceFiles(newFiles) {
        const filesToInvalidate = [];
        for (const [virtualPath, content] of files) {
          if (!newFiles.has(virtualPath) || newFiles.get(virtualPath) !== content) {
            filesToInvalidate.push(virtualPath);
          }
        }
        files = newFiles;
        if (serverInstance) {
          for (const virtualPath of filesToInvalidate) {
            const resolvedId = `${resolvedPrefix}${virtualPath}`;
            const mod = serverInstance.moduleGraph.getModuleById(resolvedId);
            if (mod) {
              serverInstance.reloadModule(mod);
            }
          }
        } else {
          console.warn("Server instance not found, cannot invalidate files");
        }
      }
    }
  };
}
function replaceFiles(plugin, newFiles) {
  return plugin[API_PROPERTY].replaceFiles(newFiles);
}

// src/server/toolpadAppBuilder.ts
var currentDirectory = url.fileURLToPath(new URL(".", import.meta.url));
var pkgJsonContent = fs.readFileSync(path3.resolve(currentDirectory, "../../package.json"), {
  encoding: "utf-8"
});
var pkgJson = JSON.parse(pkgJsonContent);
var TOOLPAD_BUILD = process.env.GIT_SHA1?.slice(0, 7) || "dev";
var MAIN_ENTRY = "/main.tsx";
var EDITOR_ENTRY = "/editor.tsx";
var FALLBACK_MODULES = [
  "@mui/material",
  "@mui/icons-material",
  "@mui/x-data-grid",
  "@mui/x-charts"
];
function getHtmlContent(entry) {
  return `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <title>Toolpad</title>
        <link
          rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
        />
      </head>
      <body>
        <div id="root"></div>
    
        <!-- __TOOLPAD_SCRIPTS__ -->

        <script type="module" src=${JSON.stringify(entry)}></script>
      </body>
    </html>
  `;
}
function getAppHtmlContent() {
  return getHtmlContent(MAIN_ENTRY);
}
function getEditorHtmlContent() {
  return getHtmlContent(EDITOR_ENTRY);
}
function toolpadVitePlugin() {
  return {
    name: "toolpad",
    async resolveId(id, parent) {
      if (id.endsWith(".html")) {
        return id;
      }
      const hasFallback = FALLBACK_MODULES.some(
        (moduleName) => moduleName === id || id.startsWith(`${moduleName}/`)
      );
      if (hasFallback) {
        const [userMod, fallbackMod] = await Promise.all([
          this.resolve(id, parent),
          this.resolve(id, currentDirectory)
        ]);
        return userMod || fallbackMod;
      }
      return null;
    },
    async load(id) {
      if (id.endsWith("index.html")) {
        return getAppHtmlContent();
      }
      if (id.endsWith("editor.html")) {
        return getEditorHtmlContent();
      }
      return null;
    },
    transform(code, id) {
      if (/\/resources\//.test(id)) {
        const codeFile = path3.basename(id);
        const functionExports = [];
        const lines = code.split("\n");
        for (let i = 0; i < lines.length; i += 1) {
          const line = lines[i];
          const lineNr = i + 1;
          if (/\s*export\b/.test(line)) {
            const match = line.match(/\s*export\s+async\s+function\s+([a-zA-Z0-9]+)\b/);
            if (match) {
              const functionName = match[1];
              functionExports.push(functionName);
            } else {
              console.warn(
                `Unsupported export at "${id}:${lineNr}". Only exports of the form "export async function foo(...) {" are supported.`
              );
            }
          }
        }
        return `
          import { createRemoteFunction } from '@mui/toolpad/runtime';

          const functionFile = ${JSON.stringify(codeFile)};

          ${functionExports.map(
          (functionName) => `const __${functionName} = createRemoteFunction(functionFile, ${JSON.stringify(
            functionName
          )})`
        ).join("\n")}

          export {
            ${functionExports.map((functionName) => `__${functionName} as ${functionName}`).join(",\n")}
          }
        `;
      }
      return code;
    }
  };
}
async function createViteConfig({
  toolpadDevMode,
  outDir,
  root,
  dev,
  base,
  customServer,
  plugins = [],
  getComponents: getComponents2,
  loadDom: loadDom2,
  getPagesManifest: getPagesManifest2
}) {
  const mode = dev ? "development" : "production";
  const getEntryPoint = (target) => {
    const isCanvas = target === "dev";
    const isEditor = target === "editor";
    const componentsId = "virtual:toolpad-files:components.tsx";
    const pageComponentsId = "virtual:toolpad-files:page-components.tsx";
    return `
import { init, setComponents } from '@mui/toolpad/entrypoint';
import components from ${JSON.stringify(componentsId)};
import pageComponents from ${JSON.stringify(pageComponentsId)};
${isCanvas ? `import AppCanvas from '@mui/toolpad/canvas'` : ""}
${isEditor ? `import ToolpadEditor from '@mui/toolpad/editor'` : ""}

const initialState = window[${JSON.stringify(INITIAL_STATE_WINDOW_PROPERTY)}];

setComponents(components, pageComponents);

init({
  ${isCanvas ? `ToolpadApp: AppCanvas,` : ""}
  ${isEditor ? `ToolpadApp: ToolpadEditor,` : ""}
  base: ${JSON.stringify(base)},
  initialState,
})

if (import.meta.hot) {
  // TODO: investigate why this doesn't work, see https://github.com/vitejs/vite/issues/12912
  import.meta.hot.accept(
    [${JSON.stringify(componentsId)}, ${JSON.stringify(pageComponentsId)}],
    (newComponents, newPageComponents) => {
    if (newComponents) {
      console.log('hot updating Toolpad components')
      setComponents(
        newComponents ?? components,
        newPageComponents ?? pageComponents
      );
    }
  });
}
`;
  };
  const createComponentsFile = async () => {
    const components = await getComponents2();
    const imports = components.map(
      ({ name }) => `import ${name} from 'toolpad-user-project:./components/${name}';`
    );
    const defaultExportProperties = components.map(
      ({ name }) => `${JSON.stringify(`codeComponent.${name}`)}: ${name}`
    );
    const code = `
      ${imports.join("\n")}

      export default {
        ${indent(defaultExportProperties.join(",\n"), 2)}
      };
    `;
    return {
      code,
      map: null
    };
  };
  const createPageComponentsFile = async () => {
    const dom = await loadDom2();
    const appNode = appDom.getApp(dom);
    const { pages = [] } = appDom.getChildNodes(dom, appNode);
    const imports = /* @__PURE__ */ new Map();
    for (const page of pages) {
      const codeFile = page.attributes.codeFile;
      if (codeFile) {
        const importPath = path3.resolve(root, `./pages/${page.name}/page`);
        const relativeImportPath = path3.relative(root, importPath);
        const importSpec = `toolpad-user-project:${pathToNodeImportSpecifier(relativeImportPath)}`;
        imports.set(page.name, importSpec);
      }
    }
    const importLines = Array.from(
      imports.entries(),
      ([name, spec]) => `${name}: React.lazy(() => import(${JSON.stringify(spec)}))`
    );
    const code = `
      import * as React from 'react';
      
      export default {
        ${importLines.join(",\n")}
      }
    `;
    return {
      code,
      map: null
    };
  };
  const virtualFiles = /* @__PURE__ */ new Map([
    ["main.tsx", getEntryPoint("prod")],
    ["dev.tsx", getEntryPoint("dev")],
    ["editor.tsx", getEntryPoint("editor")],
    ["components.tsx", await createComponentsFile()],
    ["page-components.tsx", await createPageComponentsFile()],
    ["pages-manifest.json", JSON.stringify(await getPagesManifest2(), null, 2)]
  ]);
  const virtualToolpadFiles = virtualFsPlugin(virtualFiles, "toolpad-files");
  return {
    reloadComponents: async () => {
      const newFiles = new Map(virtualFiles);
      newFiles.set("components.tsx", await createComponentsFile());
      replaceFiles(virtualToolpadFiles, newFiles);
    },
    viteConfig: {
      configFile: false,
      mode,
      build: {
        outDir,
        emptyOutDir: true,
        chunkSizeWarningLimit: Infinity,
        rollupOptions: {
          input: {
            index: path3.resolve(currentDirectory, "./index.html"),
            ...process.env.EXPERIMENTAL_INLINE_CANVAS && dev ? { editor: path3.resolve(currentDirectory, "./editor.html") } : {}
          },
          onwarn(warning, warn) {
            if (warning.code === "MODULE_LEVEL_DIRECTIVE") {
              return;
            }
            warn(warning);
          }
        }
      },
      envFile: false,
      resolve: {
        dedupe: FALLBACK_MODULES,
        alias: [
          {
            // FIXME(https://github.com/mui/material-ui/issues/35233)
            find: /^@mui\/icons-material\/(?!esm\/)([^/]*)/,
            replacement: "@mui/icons-material/esm/$1"
          },
          {
            find: /^toolpad-user-project:(.*)$/,
            replacement: `${root}/$1`
          },
          {
            find: MAIN_ENTRY,
            // eslint-disable-next-line no-nested-ternary
            replacement: process.env.EXPERIMENTAL_INLINE_CANVAS ? "virtual:toolpad-files:main.tsx" : dev ? "virtual:toolpad-files:dev.tsx" : "virtual:toolpad-files:main.tsx"
          },
          {
            find: "@mui/toolpad",
            replacement: toolpadDevMode ? (
              // load source
              path3.resolve(currentDirectory, "../../src/exports")
            ) : (
              // load compiled
              path3.resolve(currentDirectory, "../exports")
            )
          },
          ...process.env.EXPERIMENTAL_INLINE_CANVAS && dev ? [
            {
              find: EDITOR_ENTRY,
              replacement: "virtual:toolpad-files:editor.tsx"
            },
            {
              find: "vm",
              replacement: "vm-browserify"
            }
          ] : []
        ]
      },
      server: {
        fs: {
          allow: [root, path3.resolve(currentDirectory, "../../../../")]
        }
      },
      optimizeDeps: {
        force: !process.env.EXPERIMENTAL_INLINE_CANVAS && toolpadDevMode ? true : void 0,
        include: [
          ...FALLBACK_MODULES.map((moduleName) => `@mui/toolpad > ${moduleName}`),
          ...process.env.EXPERIMENTAL_INLINE_CANVAS && dev ? [
            "perf-cascade",
            "monaco-editor",
            "monaco-editor/esm/vs/basic-languages/javascript/javascript",
            "monaco-editor/esm/vs/basic-languages/typescript/typescript",
            "monaco-editor/esm/vs/basic-languages/markdown/markdown"
          ] : []
        ]
      },
      appType: "custom",
      logLevel: "info",
      root: currentDirectory,
      plugins: [toolpadVitePlugin(), virtualToolpadFiles, react(), ...plugins],
      base,
      define: {
        "process.env.NODE_ENV": `'${mode}'`,
        "process.env.BASE_URL": `'${base}'`,
        "process.env.TOOLPAD_CUSTOM_SERVER": `'${JSON.stringify(customServer)}'`,
        "process.env.TOOLPAD_VERSION": JSON.stringify(pkgJson.version),
        "process.env.TOOLPAD_BUILD": JSON.stringify(TOOLPAD_BUILD),
        "process.env.EXPERIMENTAL_INLINE_CANVAS": JSON.stringify(
          process.env.EXPERIMENTAL_INLINE_CANVAS
        )
      }
    }
  };
}

// src/runtime/createRuntimeState.tsx
import * as appDom2 from "@mui/toolpad-core/appDom";
function createRuntimeState({ dom }) {
  return {
    dom: appDom2.createRenderTree(dom)
  };
}

// src/server/toolpadAppServer.ts
import * as express3 from "express";
import serializeJavascript from "serialize-javascript";

// src/server/config.ts
function readConfig() {
  if (typeof window !== "undefined") {
    throw new Error(`Server-side config can't be loaded on the client side`);
  }
  const encryptionKeys = process.env.TOOLPAD_ENCRYPTION_KEYS?.split(/\s+/).filter(Boolean) ?? [];
  let basicAuthConfig = {};
  if (process.env.TOOLPAD_BASIC_AUTH_USER && process.env.TOOLPAD_BASIC_AUTH_PASSWORD) {
    basicAuthConfig = {
      basicAuthUser: process.env.TOOLPAD_BASIC_AUTH_USER,
      basicAuthPassword: process.env.TOOLPAD_BASIC_AUTH_PASSWORD
    };
  } else if (process.env.TOOLPAD_BASIC_AUTH_USER) {
    throw new Error(
      `Basic Auth user configured without password. Please provide the TOOLPAD_BASIC_AUTH_PASSWORD environment variable.`
    );
  }
  return {
    ...basicAuthConfig,
    databaseUrl: process.env.TOOLPAD_DATABASE_URL,
    googleSheetsClientId: process.env.TOOLPAD_DATASOURCE_GOOGLESHEETS_CLIENT_ID,
    googleSheetsClientSecret: process.env.TOOLPAD_DATASOURCE_GOOGLESHEETS_CLIENT_SECRET,
    encryptionKeys
  };
}
var config_default = readConfig();

// src/server/rpc.ts
import * as superjson from "superjson";
import express from "express";
import * as z from "zod";
import { fromZodError } from "zod-validation-error";
import { hasOwnProperty } from "@mui/toolpad-utils/collections";
import { errorFrom, serializeError } from "@mui/toolpad-utils/errors";
import { withContext, createServerContext } from "@mui/toolpad-core/serverRuntime";
var rpcRequestSchema = z.object({
  name: z.string(),
  params: z.array(z.any())
});

// src/server/auth.ts
import express2 from "express";
import { Auth } from "@auth/core";
import GithubProvider from "@auth/core/providers/github";
import GoogleProvider from "@auth/core/providers/google";
import AzureADProvider from "@auth/core/providers/azure-ad";
import CredentialsProvider from "@auth/core/providers/credentials";
import chalk from "chalk";
import * as appDom3 from "@mui/toolpad-core/appDom";
import { adaptRequestFromExpressToFetch } from "@mui/toolpad-utils/httpApiAdapters";
import { getUserToken } from "@mui/toolpad-core/auth";

// src/server/toolpadAppServer.ts
function postProcessHtml(html, { config, initialState }) {
  const serializedConfig = serializeJavascript(config, { ignoreFunction: true });
  const serializedInitialState = serializeJavascript(initialState, { isJSON: true });
  const toolpadScripts = [
    `<script>window[${JSON.stringify(
      RUNTIME_CONFIG_WINDOW_PROPERTY
    )}] = ${serializedConfig}</script>`,
    `<script>window[${JSON.stringify(
      INITIAL_STATE_WINDOW_PROPERTY
    )}] = ${serializedInitialState}</script>`
  ];
  return html.replace(`<!-- __TOOLPAD_SCRIPTS__ -->`, () => toolpadScripts.join("\n"));
}

// src/server/appServerWorker.ts
var { notifyReady, loadDom, getComponents, getPagesManifest } = createRpcClient(
  workerData.mainThreadRpcPort
);
invariant(
  process.env.NODE_ENV === "development",
  "The dev server must be started with NODE_ENV=development"
);
function devServerPlugin({ config }) {
  return {
    name: "toolpad-dev-server",
    async configureServer(viteServer) {
      return () => {
        viteServer.middlewares.use("/", async (req, res, next) => {
          invariant(req.url, "request must have a url");
          try {
            const dom = await loadDom();
            const template = process.env.EXPERIMENTAL_INLINE_CANVAS ? getEditorHtmlContent() : getAppHtmlContent();
            let html = await viteServer.transformIndexHtml(req.url, template);
            html = postProcessHtml(html, {
              config,
              initialState: createRuntimeState({ dom })
            });
            res.setHeader("content-type", "text/html; charset=utf-8").end(html);
          } catch (e) {
            next(e);
          }
        });
      };
    }
  };
}
async function main({ port, ...config }) {
  const { reloadComponents, viteConfig } = await createViteConfig({
    ...config,
    dev: true,
    plugins: [devServerPlugin(config)],
    getComponents,
    getPagesManifest,
    loadDom
  });
  const vite = await import("vite");
  const devServer = await vite.createServer(viteConfig);
  await devServer.listen(port);
  invariant(parentPort, "parentPort must be defined");
  parentPort.on("message", async (msg) => {
    switch (msg.kind) {
      case "reload-components": {
        reloadComponents();
        break;
      }
      case "exit": {
        await devServer.close();
        break;
      }
      default:
        throw new Error(`Unknown command ${msg}`);
    }
  });
  await notifyReady();
}
main(workerData);
export {
  main
};
//# sourceMappingURL=appServerWorker.mjs.map